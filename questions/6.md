Работа с файловой системой
Взаимодействие с файлами не ограничивается только самими файлами, нам часто приходится работать и с папками. Главными героями этого раздела будут библиотеки os и os.path. Они связаны с операционной системой компьютера и позволяют взаимодейстовать с файловой системой.

Все папки директории
os.listdir(dir) перечисялет файлы и папки в указанной директории dir. Если вызвать эту функцию без аргументов, она вернет файлы и папки текущей рабочей директории.

Текущая папка
Относительные пути строятся относительно текущей папки. Чтобы получить абсолютный путь файла из относительного, используется функция os.path.abspath(file_path). Чтобы узнать, какая папка является текущей, можно вызвать функцию os.getcwd(). Для смены текущей папки используется os.chdir(new_dir).

Проверка существования файла или папки и определение, является ли имя файлом или папкой
os.path.exists(file_name) проверяет, существует ли указанный файл (или директория) file_name.

Чтобы проверить, является ли данное имя name файлом или папкой, можно воспользоваться функциями os.isdir(name) или os.isfile(name), которые возвращают True или False.

Рекурсивный обход папок
Одной из самых интересных и мощных функций является функция os.walk(dir) - она позволяет рекурсивно пройтись по всем папкам, подпапкам, их подпапкам и так далее. На самом деле она возвращает генератор (последовательность элементов). Каждый элемент представляеьт собой кортеж из 3х элементов. Первый элемнт - строковое представление директории текущей директории, которую просматривает функция. Вторым элементом - список всех подпапок данной директории, а третьим - список всех файлов этой директории.

for current_dir, dirs, files in os.walk("."): #передаем в качестве аргумента текущую директорию
                                              #("." - означает именно ее)
    print(current_dir, dirs, files)           #выведем, что получается
Копирование файлов
Копировать файлы можно при помощи функции copy из модуля shutil

shutil.copy("input.txt", "output.txt")
Копировать папки можно с помощью copytree из того же модуля:

shutil.copytree("test", "test/test2") #Скопирует папку test внутрь неё самой же в подпапку test2
Многие другие функции для работы с файлами и папками вы сможете найти в модулях os и shutil. Теперь вы знаете, где искать нужный функционал ;)

Упражнение 3: Вам дана в архиве файловая структура, состоящая из директорий и файлов.

Вам необходимо распаковать этот архив (средствами языка python), и затем найти в данной в файловой структуре все директории, в которых есть хотя бы один файл с расширением “.py”.

Ответом на данную задачу будет являться файл со списком таких директорий, отсортированных в лексикографическом порядке.

Распространенные форматы текстовых данных
csv
csv является табличным форматом. В нем содержатся значения разделенные запятой (Comma-Separated Values). Например,

first name,last name,module1,module2,module3
Nikolay,Neznaev,0,20,10
Stepan,Sharyashiy,100,99.5,100
Для работы с csv файлами можно воспользоваться библиотекой csv:

import csv
with open("example.csv", "r") as file:
    reader = csv.reader(file) #На основе открытого файла получаем объект из библиотеки csv
    for row in reader:
        print(row)            #Каждая строка - список значений
В csv.reader параметром delimeter можно передать разделитель значений, таким образом разделяющим символом в файле csv может быть не только запятая.
Для изолирования некоторых значений можно пользоваться двойными кавычками. Библиотека csv учитывает различные мелочи, такие как строки с содержащимися в ней запятыми и переносами строки, различные разделители, поэтому ее использование целесообразнее splitа по разделителю.
Для записи значений в csv формате используется csv.writer:
import csv
students = [
            ["Greg", "Lebovskiy", 70, 80, 90, "Good job, Greg!"],
            ["Nick", "Shalopaev", 10, 50, 45, "Shalopaev, you should study better!"]
            ]
with open("example.csv", "a") as file:
    writer = csv.writer(file)            #На основе открытого файла получаем объект из библиотеки csv
    for student in students:
        writer.writerow(student)         #Записываем строку
    #Вместо цикла выше мы могли сразу записать все через writer.writerows(students)
JSON
JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Впервые он был придуман и использован в JavaScript для хранения структур и классов, но быстро обео свою популярность и вышел за пределы своего родителя.
JSON основан на двух структурах данных: * Коллекция пар ключ/значение. В разных языках, эта концепция реализована как объект, запись, структура, словарь, хэш, именованный список или ассоциативный массив. * Упорядоченный список значений. В большинстве языков это реализовано как массив, вектор, список или последовательность.
Это универсальные структуры данных. Почти все современные языки программирования поддерживают их в какой-либо форме. Логично предположить, что формат данных, независимый от языка программирования, должен быть основан на этих структурах.

Объекты в формате SJON хранятся как словари в Python, но с некоторыми деталями: во первых, ключом в json-объекте может быть только строка, значения True и False пишутся с маленькой буквы, значению None соответствует значение null, строки хранятся только внутри двойных кавычек.

Для удобной работы с json файлами в языке python можно использовать библиотеку json

Например:

import json

student1 = {
    "full_name" : "Greg Martin",
    "scores" : [100, 85, 94],
    "certificate" : True,
    "comment": "Great job, Greg!"
}

student2 = {
    "full_name" : "John Price",
    "scores" : [0, 10, 0],
    "certificate" : False,
    "comment": "Guns aren't gonna help you here, captain!"
}

data = [student1, student2]

print(json.dumps(data, indent=4, sort_keys=True)) #Делаем отступы в 4 пробела, сортируем ключи в алфавитном порядке
Для получения строкового представления объекта в формате json можно использовать json.dumps(data, **parrams) с различными вспомогательными настройками (пробелы, сортировка и др.)
Для записи в файл можно воспользоваться json.dump(data, file_obj, **params):
with open("output.json", "w") as out:
    json.dump(data, out, indent=4, sort_keys=True)
Для получения объекта python на основе его срокового представления можно воспользоваться функцией json.loads или json.load для считывания из файла:

json_str = json.dumps(data, indent=4, sort_keys=True) #получение строкового представления json
data_again = json.loads(json_str)                     #получаем объект python
print(sum(data_again[0]["scores"]))                   #убедимся в кореектном считывании:
                                                      #посчитаем сумму баллов у первого студента

with open("output.json") as file:
   data_from_file = json.load(file)                   #считаем объект из файла
   print(sum(data_from_file[0]["scores"]))            #аналогично посчитаем сумму баллов


Блок  try-except с текстовыми файлами на Python
Одна из стандартных проблем при работе с файлами, это отсутствие необходимого файла, или файл находится в другом месте и Python не может его найти. Попробуем прочитать не существующий файл:

filename = 'alice_2.txt'

with open(filename, encoding='utf-8') as file:
    contents = file.read()

Так как такого файла не существует, Python выдает исключение:

Traceback (most recent call last):
  File "example.py", line 3, in <module>
    with open(filename, encoding='utf-8') as file:
FileNotFoundError: [Errno 2] No such file or directory: 'alice_2.txt'

FileNotFoundError - это ошибка отсутствия запрашиваемого файла. С помощью блока try-except обработаем ее:

filename = 'alice_2.txt'

try:
    with open(filename, encoding='utf-8') as file:
        contents = file.read()
except FileNotFoundError:
    print(f"Запрашиваемый файл {filename } не найден")

В результате при отсутствии файла мы получим:

Запрашиваемый файл alice_2.txt не найден

 

Ошибки без уведомления пользователя
В предыдущих примерах мы сообщали пользователю об ошибках. В Python есть возможность обработать ошибку и не сообщать пользователю о ней и продолжить выполнение программы дальше. Для этого блок try пишется, как и обычно, а в блоке except вы прописываете Python не предпринимать никаких действий с помощью команды pass. Приведем пример ошибки без уведомления:

ilename = 'alice_2.txt'

try:
    with open(filename, encoding='utf-8') as file:
        contents = file.read()
except FileNotFoundError:
    pass

В результате при запуске этой программы и отсутствия запрашиваемого файла ничего не произойдет.  
# Работа с файловой системой

### Работа с файлами: поиск на ФС, открытие, чтение, запись и т.п. Чтение директорий. Получение метаинформации о файлах. Ошибки, возникающие при работе с файлами.

### **Поиск на файловой системе**

Поиск на файловой системе в Python можно осуществить с помощью модуля os. Он предоставляет функции для работы с операционной системой, включая поиск файлов и директорий. 

- Для поиска файлов на файловой системе в Python можно использовать модуль `os` или `glob`.
- Например, функция `os.listdir()` возвращает список файлов и папок в указанной директории.

### **Открытие файлов**

Для открытия файла в Python используется функция open(), которая возвращает объект файла. Она принимает два аргумента: путь к файлу и режим открытия.

```python
file = open('путь/к/файлу', 'режим')
```

Режимы открытия файлов могут быть:

- 'r': чтение файла (по умолчанию)
- 'w': запись в файл, существующий файл будет перезаписан
- 'a': добавление в конец файла, если файл не существует, он будет создан
- 'x': создание файла для записи, если файл уже существует, будет вызвано исключение FileExistsError
- 'b': двоичный режим
- 't': текстовый режим (по умолчанию)

### **Чтение файлов**

После открытия файла в режиме чтения ('r'), можно использовать методы объекта файла для чтения его содержимого. Например, метод read() читает весь файл и возвращает его содержимое в виде строки.

```python
file = open('путь/к/файлу', 'r')
content = file.read()
file.close()
```

Также можно читать файл построчно с помощью метода readline() или получать список строк с помощью метода readlines().

**Кодировка (encode/decode):**

- При открытии файла можно указать кодировку для чтения или записи текста.
- Например, `open('file.txt', 'r', encoding='utf-8')`.

### **Запись файлов**

После открытия файла в режиме записи ('w' или 'a'), можно использовать методы объекта файла для записи в него. Например, метод write() записывает переданную строку в файл.

```python
file = open('путь/к/файлу', 'w')
file.write('Привет, мир!')
file.close()
```

Также можно использовать метод writelines(), который принимает список строк и записывает их построчно в файл.

### **Чтение директорий**

Для чтения содержимого директории в Python можно использовать функцию os.listdir(). Она возвращает список файлов и директорий в указанной директории.

```python
import os

files = os.listdir('путь/к/директории')
for file in files:
    print(file)
```

### **Получение метаинформации о файлах**

Модуль os предоставляет функции для получения метаинформации о файлах, таких как размер, время создания и время последнего доступа. Например, функция os.path.getsize() возвращает размер файла в байтах.

```python
import os

file_size = os.path.getsize('путь/к/файлу')
print(file_size)
```

Другие функции, такие как os.path.getctime(), os.path.getmtime(), os.path.getatime(), возвращают время создания, последнего изменения и последнего доступа к файлу соответственно.

### **Ошибки, возникающие при работе с файлами**

При работе с файлами в Python могут возникать различные ошибки. Некоторые из них:

- FileNotFoundError: возникает, если файл не найден
- PermissionError: возникает, если нет разрешения на доступ к файлу
- IsADirectoryError: возникает, если пытаетесь открыть директорию вместо файла
- FileExistsError: возникает, если пытаетесь создать файл, который уже существует
- IOError: возникает, если произошла ошибка ввода-вывода
- Почему важно закрывать файл: Ошибка слишком много открытых файлов (когда в бесконечном цикле читаем файл и не закрываем)

Для обработки ошибок при работе с файлами в Python используются конструкции try-except-finally.

## ВТОРОЙ ВАРИАНТ:

1. **Поиск на файловой системе:**
    - Для поиска файлов на файловой системе в Python можно использовать модуль `os` или `glob`.
    - Например, функция `os.listdir()` возвращает список файлов и папок в указанной директории.
2. **Открытие, чтение и запись файлов:**
    - Для открытия файла в Python используется функция `open()`.
    - Функция `open()` принимает два обязательных аргумента: имя файла и режим доступа (например, 'r' для чтения, 'w' для записи).
    - Чтение файла:
        - Метод read() читает весь файл целиком и возвращает его содержимое как строку.
        - Метод readlines() читает файл построчно и возвращает список строк.
        - Метод readline() читает одну строку из файла и перемещает указатель на следующую строку.
    - Запись в файл:
        - Метод `write()` записывает строку в файл.
        - Если файл не существует, он будет создан. Если файл уже существует, его содержимое будет перезаписано.
    - Важно помнить о необходимости закрытия файла после работы с ним для освобождения ресурсов:
        - Метод `close()` закрывает файл.
        - Открытые файлы могут занимать системные ресурсы, поэтому важно закрывать их после использования.
3. **Использование with open:**
    - Контекстный менеджер `with open` автоматически закрывает файл после завершения работы в блоке `with`.
    - Это помогает избежать забывчивости и ошибок при работе с файлами.
    - Пример использования:
        
        `with open('file.txt', 'r') as f:`
        # работа с файлом
        
4. **Получение метаинформации о файлах:**
    - Для получения метаинформации о файлах (например, размер, дата создания) можно использовать модуль os или os.path.
    - Например, функция `os.path.getsize()` возвращает размер файла в байтах.
5. **Ошибки при работе с файлами:**
    - Слишком много открытых файлов: Важно закрывать файлы после использования, особенно в циклах, чтобы не превысить лимит открытых файлов.
    - Попытка открыть директорию вместо файла: Проверьте тип объекта перед открытием, чтобы убедиться, что это файл.
    - Попытка открыть несуществующий файл: Обработайте исключение `FileNotFoundError`, чтобы предотвратить ошибку.
    - Попытка записать туда, куда нельзя: Убедитесь, что у вас есть права на запись в указанное место.
6. **Кодировка (encode/decode):**
    - При открытии файла можно указать кодировку для чтения или записи текста.
    - Например, `open('file.txt', 'r', encoding='utf-8')`.
7. **Ошибки при работе с файлами:**
    - Попытка открыть директорию вместо файла: Проверьте тип объекта перед открытием, чтобы убедиться, что это файл.
    - Попытка открыть несуществующий файл: Обработайте исключение `FileNotFoundError`, чтобы предотвратить ошибку.
    - Попытка записать туда, куда нельзя: Убедитесь, что у вас есть права на запись в указанное место.

