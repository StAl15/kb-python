# 4. Работа с текстовыми данными

Тип данных str. Юникод и кодировки. Текстовые файлы. Разбор текстовых
данных. Регулярные выражения.

**Тип данных str:**

**Строки** - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

**Строки в апострофах и в кавычках**

```python
s = "spam's"
s = 'spam"s'
```

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование.

**Экранированные последовательности - служебные символы**

Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры:

- \n - перевод строки
- \r - возврат каретки
- \t - горизонтальная табуляция
- \v - вертикальная табуляция
- \xhh - 16-ричное значение символа
- etc...

**"Сырые" строки - подавляют экранирование**

Если перед открывающей кавычкой стоит символ 'r' , то механизм экранирования отключается:

```python
s = r'C:\newt.txt'
```

**Строки в тройных апострофах или кавычках**

Главное достоинство строк в тройных кавычках в том, что их можно использовать для записи многострочных блоков текста. Внутри такой строки возможно присутствие кавычек и апострофов, главное, чтобы не было трех кавычек подряд.

```python
c = '''это очень большая строка,
многострочный блок текста'''
```

**Юникод и кодировки:**

Юникод - это стандарт, который представляет символы из всех письменных систем в виде числовых кодов. Он позволяет представлять символы различных языков и символы, такие как эмодзи, в компьютерных системах. Кодировка - это способ преобразования символов в биты для их хранения и передачи.

Пример кодировки UTF-8:

```python
name = "Саша"
encoded_name = name.encode('utf-8')# Преобразование строки в байтовую последовательность
print(encoded_name)# Вывод: b'\xd0\xa1\xd0\xb0\xd1\x88\xd0\xb0'
decoded_name = encoded_name.decode('utf-8')# Преобразование байтовой последовательности в строку
print(decoded_name)# Вывод: Саша
```

**Исходный код**

Файлы исходного кода должны использовать UTF-8, если же есть необходимость сохранить файл в другой кодировке - используется специальный комментарий в начале файла.

# -*- coding: <имя кодировки> -*-

**Строки**

По умолчанию в python3 используется кодировка UTF-8, все объекты str хранятся в этой кодировке. Нестанадартные символы могут быть заданы экранирующими последовательностями:

```python
"\u0394" # Используем 16-битное значение

"\U00000394" # Используем 32-битное значение
```

Еще один способ создать строку - метод [decode()](https://docs.python.org/3/library/stdtypes.html#bytes.decode) объекта [bytes](https://docs.python.org/3/library/functions.html#bytes). В качестве аргумента он принимает кодировку:

```python
s1 = b'\x80abc'.decode("utf-8")  # 'abc'
```

Кодировка задается в виде предопределенной строки. Python 3 поддерживает около 100 кодировок.

Обратный метод преобразования, str.encode() возвращает объект bytes - представление строки в виде байтов с учетом конкретной кодировки. Принимает те же аргументы на вход, что и decode().

**Текстовые файлы:**

Текстовые файлы представляют собой файлы, содержащие текстовую информацию. В Python можно открывать, считывать, записывать и закрывать текстовые файлы с помощью функций open(), read(), write() и close() соответственно.

Пример открытия и чтения файла:

```python
file = open('example.txt', 'r')# Открытие файла для чтения
content = file.read()# Чтение всего содержимого файла
print(content)# Вывод содержимого файла
file.close()# Закрытие файла
```

**Разбор текстовых данных:**

Разбор текстовых данных - это процесс анализа и извлечения полезной информации из текста. В Python для разбора текстовых данных можно использовать различные методы и функции, такие как split(), splitlines(), strip(), find(), startswith() и другие.

Примеры:

```python
text = "Hello, World!"
words = text.split(", ")# Разделение текста на отдельные слова
print(words)# Вывод: ['Hello', 'World!']

lines = "Line 1\nLine 2\nLine 3"
lines_list = lines.splitlines()# Разделение текста на отдельные строки
print(lines_list)# Вывод: ['Line 1', 'Line 2', 'Line 3']

sentence = "   Hello, World!   "
stripped_sentence = sentence.strip()# Удаление пробелов в начале и конце строки
print(stripped_sentence)# Вывод: 'Hello, World!'

index = text.find("World")# Поиск позиции первого вхождения подстроки
print(index)# Вывод: 7

starts_with_hello = text.startswith("Hello")# Проверка, начинается ли строка с указанной подстроки
print(starts_with_hello)# Вывод: True
```

**Регулярные выражения:**

Регулярные выражения - это мощный инструмент для работы с текстовыми данными, позволяющий выполнять сложные операции поиска и обработки текста. В Python для работы с регулярными выражениями используется модуль **re.**

Примеры:

```python
import re

text = "Hello, World!"

match = re.search(r"Hello", text)# Поиск первого совпадения с регулярным выражением
print(match.group())# Вывод: 'Hello'

matches = re.findall(r"\w+", text)# Поиск всех слов в тексте
print(matches)# Вывод: ['Hello', 'World']

replaced_text = re.sub(r"Hello", "Hi", text)# Замена всех совпадений регулярного выражения в тексте
print(replaced_text)# Вывод: 'Hi, World!
```

***Сайт для тренировки регвыр:*** 

[RegexOne - Learn Regular Expressions - Lesson 1: An Introduction, and the ABCs](https://regexone.com/lesson/introduction_abcs)

**Синтаксис**

Внутри регвыра символы ., ^, $, *, +, ?, {, [, ], \, |, (, ) имеют специальное значение. Их следует экранировать с помощью слэша.

- [...] - в квадратных скобках можно указать символы, которые могут встречаться на этом месте в строке. Можно перечислять символы подряд или указать диапазон через тире.
    - Например, [а-яА-ЯёЁ] соответствует любой русской букве («ё» и «Ё» не входят в диапазоны [а-я] и [А-Я] соответственно.)
    - Можно указать символы, которых не должно быть на этом месте в строке. Для этого используется ^ сразу после открывающейся квадратной скобки (например, [^0-9] — не цифра от 0 до 9).
- ^ - привязка к началу строки или подстроки.
- $ - привязка к концу строки или подстроки.
- {...} - квантификаторы - количество вхождений символа в строку.
    - {n} — n вхождений символа в строку.
    - {n,} - n или более вхождений символа в строку.
    - {n,m} — не менее n и не более m вхождений символа в строку.
    - - ноль или более вхождений.
    - + - одно или большее число вхождений.
    - ? - ни одного или одно вхождение символа.
    - Все квантификаторы — жадные (ищется самая длинная подстрока). Чтобы ограничить жадность, необходимо после квантификатора указать символ ?.
- Стандартные классы:
    - \d — любая цифра.
    - \w — любая цифра, буква или символ подчеркивания.
    - \s — любой пробельный символ.
    - \D — не цифра.
    - \W — не буква, не цифра и не символ подчеркивания.
    - \S — не пробельный символ.
- (...) - Круглые скобки часто используются для группировки фрагментов внутри шаблона. Чтобы избежать захвата фрагмента, следует после открывающейся круглой скобки разместить символы ?: .

К найденному фрагменту в круглых скобках внутри шаблона можно обратиться с помощью механизма обратных ссылок. Для этого порядковый номер круглых скобок указывается после слэша, например, \1. Нумерация скобок начинается с 1.

Существует также возможность сравнения шаблона с предыдущими и последующими символами:

- (?=...) - положительный просмотр вперед.
- (?!...) - отрицательный просмотр вперед.
- (?<=...) - положительный просмотр назад.
- (?<!...) - отрицательный просмотр назад.
- Требуется, чтобы шаблоны, используемые при просмотре назад, имели фиксированную длину. Т.е. , к примеру, можно использовать (?<=[,]), но нельзя использовать (?<=[,]+).

**Методы**

compile() - создание откомпилированного шаблона регулярного выражения.

Формат: re.compile(регвыр, модификатор)

Поиск первого совпадения с шаблоном:

- match() - проверяет соответствие с началом строки. Возвращает объект Match, если найдено соответствие. Иначе — None.
- search() - проверяет соответствие с любой частью строки. Возвращает объект Match, если найдено соответствие. Иначе — None.

Методы объекта Match:

- group(group1, group2, …,groupN) - возвращает фрагменты, соответствующие шаблону. Если параметр не задан или указано значение 0, то возвращается фрагмент, полностью совпадающий с шаблоном.
- groups(default_value) - возвращает кортеж, содержащий значения всех групп. С помощью параметра можно указать значение, которое будет выводиться вместо None для групп, не имеющих совпадений.
- start(group_number_or_group_name) - индекс начала фрагмента.
- end(group_number_or_group_name) - индекс конца фрагмента.
- span(group_number_or_group_name) - кортеж, содержащий начальный и конечный индексы фрагмента.

Поиск всех совпадений с шаблоном:

- findall()- если соответствия найдены, то возвращается список с фрагментами(иначе пустой список). Если внутри шаблона более одной группы, то каждый элемент списка будет кортежем, а не строкой.
- finditer()- аналогичен findall(), но возвращает итератор, а не список. В каждой итерации цикла возвращается объект Match.

Форматы использования match() search() findall() finditer() :

1. regexp_object.method_name(string,start_position,end_position)
2. re.method_name(regexp, string, modificator)

Замена в строке:

- sub() - поиск всех совпадений с шаблоном и замена их указанным значением.
- subn() - аналогичен sub(), но возвращает не строку, а кортеж из двух элементов - измененной строки и количества произведенных замен.

Форматы методов sub() и subn():

- regexp_object.method_name(new_fragment, replacement string, max replacement count)
- re.method_name(template, new_fragment, replacement string, max replacement count)

Символ 'r' перед регулярным выражением указывает, что ничего в строке не должно быть экранировано. Для поиска символа '\'необходимо использовать четыре символа '\'в регвыре без 'r', тогда как с 'r' понадобится два символа '\'.
