Бинарные файлы в отличие от текстовых хранят информацию в виде набора байт. При открытии бинарного файла на чтение или запись также надо учитывать, что нам нужно применять режим "b" в дополнение к режиму записи ("w") или чтения ("r").

При чтении мы получаем файл в виде набора байт, и наоборот, при записи в метод write() передается набор байт. Например, скопируем файл:

FILENAME = "forest.png"             # файл для чтения
NEWFILENAME = "forest_new.png"      # файл для записи
 
image_data = []     # список для хранения считанных данных
  
# считываем файл в список image_data
with open(FILENAME, "rb") as file:
    image_data = file.read()
     
# запись выше считанных байт в новый файл
with open(NEWFILENAME, "wb") as file:
    file.write(image_data)
     
print(f"Файл {FILENAME} скопирован в {NEWFILENAME}")
Считывает файл, путь к которому хранится в переменной FILENAME. В данном случае это файл изображения "forest.png". Считанные байты помещаются в список image_data. Затем этот список записываем в файл с именем NEWFILENAME. Таким образом, мы скопируем содержимое одного файла в другой.

Модуль pickle
Также для работы с бинарными файлами Python предоставляет специальный встроенный модуль pickle, который упрощает работу с бинарными файлами. Этот модуль предоставляет два метода:

dump(obj, file): записывает объект obj в бинарный файл file

load(file): считывает данные из бинарного файла в объект

Допустим, надо надо сохранить значения двух переменных:

import pickle
 
FILENAME = "user.dat"
 
name = "Tom"
age = 19
 
with open(FILENAME, "wb") as file:
    pickle.dump(name, file)
    pickle.dump(age, file)
 
with open(FILENAME, "rb") as file:
    name = pickle.load(file)
    age = pickle.load(file)
    print("Имя:", name, "\tВозраст:", age)
С помощью функции dump последовательно записываются два объекта. Поэтому при чтении файла также последовательно посредством функции load мы можем считать эти объекты. Консольный вывод программы:

Имя: Tom 		Возраст: 28
Подобным образом мы можем сохранять и извлекать из файла наборы объектов:

import pickle
 
FILENAME = "users.dat"
 
users = [
    ["Tom", 28, True],
    ["Alice", 23, False],
    ["Bob", 34, False]
]
 
with open(FILENAME, "wb") as file:
    pickle.dump(users, file)
 
 
with open(FILENAME, "rb") as file:
    users_from_file = pickle.load(file)
    for user in users_from_file:
        print("Имя:", user[0], "\tВозраст:", user[1], "\tЖенат/замужем:", user[2])
В зависимости от того, какой объект мы записывали функцией dump, тот же объект будет возвращен функцией load при считывании файла.

Консольный вывод:

Имя: Tom 		Возраст: 28 	Женат/замужем: True
Имя: Alice 		Возраст: 23 	Женат/замужем: False
Имя: Bob 		Возраст: 34 	Женат/замужем: False


Байтовые строки очень похожи на обычные строки, но с некоторыми отличиями. Попробуем выяснить, с какими.

Что такое байты? Байт - минимальная единица хранения и обработки цифровой информации. Последовательность байт представляет собой какую-либо информацию (текст, картинку, мелодию...).

Создаём байтовую строку:

>>>
>>> b'bytes'
b'bytes'
>>> 'Байты'.encode('utf-8')
b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'
>>> bytes('bytes', encoding = 'utf-8')
b'bytes'
>>> bytes([50, 100, 76, 72, 41])
b'2dLH)'
Если первые три способа нам уже известны (тут, тут и тут), то последний нужно пояснить. Функция bytes принимает список чисел от 0 до 255 и возвращает байты, получающиеся применением функции chr.

>>>
>>> chr(50)
'2'
>>> chr(100)
'd'
>>> chr(76)
'L'
Что делать с байтами? Хотя байтовые строки поддерживают практически все строковые методы, с ними мало что нужно делать. Обычно их надо записать в файл / прочесть из файла и преобразовать во что-либо другое (конечно, если очень хочется, то можно и распечатать). Для преобразования в строку используется метод decode:

>>>
>>> b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'.decode('utf-8')
'Байты'
Bytearray
Bytearray в python - массив байт. От типа bytes отличается только тем, что является изменяемым. Про него, в общем-то, больше рассказать нечего.

>>>
>>> b = bytearray(b'hello world!')
>>> b
bytearray(b'hello world!')
>>> b[0]
104
>>> b[0] = b'h'
Traceback (most recent call last):
  File "", line 1, in
    b[0] = b'h'
TypeError: an integer is required
>>> b[0] = 105
>>> b
bytearray(b'iello world!')
>>> for i in range(len(b)):
...     b[i] += i
...
>>> b
bytearray(b'ifnos%}vzun,')
