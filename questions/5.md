Бинарные файлы в отличие от текстовых хранят информацию в виде набора байт. При открытии бинарного файла на чтение или запись также надо учитывать, что нам нужно применять режим "b" в дополнение к режиму записи ("w") или чтения ("r").

При чтении мы получаем файл в виде набора байт, и наоборот, при записи в метод write() передается набор байт. Например, скопируем файл:

FILENAME = "forest.png"             # файл для чтения
NEWFILENAME = "forest_new.png"      # файл для записи
 
image_data = []     # список для хранения считанных данных
  
# считываем файл в список image_data
with open(FILENAME, "rb") as file:
    image_data = file.read()
     
# запись выше считанных байт в новый файл
with open(NEWFILENAME, "wb") as file:
    file.write(image_data)
     
print(f"Файл {FILENAME} скопирован в {NEWFILENAME}")
Считывает файл, путь к которому хранится в переменной FILENAME. В данном случае это файл изображения "forest.png". Считанные байты помещаются в список image_data. Затем этот список записываем в файл с именем NEWFILENAME. Таким образом, мы скопируем содержимое одного файла в другой.

Модуль pickle
Также для работы с бинарными файлами Python предоставляет специальный встроенный модуль pickle, который упрощает работу с бинарными файлами. Этот модуль предоставляет два метода:

dump(obj, file): записывает объект obj в бинарный файл file

load(file): считывает данные из бинарного файла в объект

Допустим, надо надо сохранить значения двух переменных:

import pickle
 
FILENAME = "user.dat"
 
name = "Tom"
age = 19
 
with open(FILENAME, "wb") as file:
    pickle.dump(name, file)
    pickle.dump(age, file)
 
with open(FILENAME, "rb") as file:
    name = pickle.load(file)
    age = pickle.load(file)
    print("Имя:", name, "\tВозраст:", age)
С помощью функции dump последовательно записываются два объекта. Поэтому при чтении файла также последовательно посредством функции load мы можем считать эти объекты. Консольный вывод программы:

Имя: Tom 		Возраст: 28
Подобным образом мы можем сохранять и извлекать из файла наборы объектов:

import pickle
 
FILENAME = "users.dat"
 
users = [
    ["Tom", 28, True],
    ["Alice", 23, False],
    ["Bob", 34, False]
]
 
with open(FILENAME, "wb") as file:
    pickle.dump(users, file)
 
 
with open(FILENAME, "rb") as file:
    users_from_file = pickle.load(file)
    for user in users_from_file:
        print("Имя:", user[0], "\tВозраст:", user[1], "\tЖенат/замужем:", user[2])
В зависимости от того, какой объект мы записывали функцией dump, тот же объект будет возвращен функцией load при считывании файла.

Консольный вывод:

Имя: Tom 		Возраст: 28 	Женат/замужем: True
Имя: Alice 		Возраст: 23 	Женат/замужем: False
Имя: Bob 		Возраст: 34 	Женат/замужем: False


Байтовые строки очень похожи на обычные строки, но с некоторыми отличиями. Попробуем выяснить, с какими.

Что такое байты? Байт - минимальная единица хранения и обработки цифровой информации. Последовательность байт представляет собой какую-либо информацию (текст, картинку, мелодию...).

Создаём байтовую строку:

>>>
>>> b'bytes'
b'bytes'
>>> 'Байты'.encode('utf-8')
b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'
>>> bytes('bytes', encoding = 'utf-8')
b'bytes'
>>> bytes([50, 100, 76, 72, 41])
b'2dLH)'
Если первые три способа нам уже известны (тут, тут и тут), то последний нужно пояснить. Функция bytes принимает список чисел от 0 до 255 и возвращает байты, получающиеся применением функции chr.

>>>
>>> chr(50)
'2'
>>> chr(100)
'd'
>>> chr(76)
'L'
Что делать с байтами? Хотя байтовые строки поддерживают практически все строковые методы, с ними мало что нужно делать. Обычно их надо записать в файл / прочесть из файла и преобразовать во что-либо другое (конечно, если очень хочется, то можно и распечатать). Для преобразования в строку используется метод decode:

>>>
>>> b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'.decode('utf-8')
'Байты'
Bytearray
Bytearray в python - массив байт. От типа bytes отличается только тем, что является изменяемым. Про него, в общем-то, больше рассказать нечего.

>>>
>>> b = bytearray(b'hello world!')
>>> b
bytearray(b'hello world!')
>>> b[0]
104
>>> b[0] = b'h'
Traceback (most recent call last):
  File "", line 1, in
    b[0] = b'h'
TypeError: an integer is required
>>> b[0] = 105
>>> b
bytearray(b'iello world!')
>>> for i in range(len(b)):
...     b[i] += i
...
>>> b
bytearray(b'ifnos%}vzun,')
Типы данных bytes, bytearray, memoryview. Бинарные файлы. Разбор
бинарных данных. Порядок байт, разрядность бинарных типов данных.

**Байтовые строки**

Байты - это байты, символы - это абстракция. Неизменяемая последовательность Unicode символов называется строкой (string). Неизменяемая последовательность чисел от 0 д 255 называется объект **bytes**.

- Чтобы создать объект bytes используется синтаксис "байтовых строк" - b"...". Каждый байт в байтовой строке может быть либо ASCII символом, либо закодированным шестнадцатеричным числом от \x00 до \xff (0-255).
- Тип байтовой строки - bytes.
- По аналогии со списками и строками, можно определить длину байтовой строки с помощью встроенной функции len().
- По аналогии со списками и строками, можно объединять байтовые строки с помощью оператора +. Результат будет новым объектом с типом bytes.
- Объединение 5-байтового и однобайтового объекта даст в результате 6-ти байтовый объект.
- По аналогии со списками и строками, можно получить конкретный байт из байтовой строки по его индексу. Элементами обычной строки выступают строки, а элементами байтовой строки являются целые числа. Конкретно числа от 0 до 255.
- Байтовая строка неизменяемая. Нельзя изменять какие-либо байты в ней.

Если bytes - неизменяемый тип, то **bytearray** - изменяемый. Это единственное отличие байтовых массивов от байтовых строк.

- Для конвертирования объекта bytes в изменяемый объект bytearray используется встроенная функция bytearray().
- Все методы и операторы, которые используются с объектами типа bytes, также подходят к объектам bytearray.
- Записываемое значение должно быть целым числом от 0 до 255.

В Python существуют три основных типа данных для работы с бинарными данными: bytes, bytearray и memoryview.

1. **bytes**: Тип данных bytes представляет неизменяемую последовательность байтов. Он используется для хранения и обработки данных в бинарном формате. Объект типа bytes имеет фиксированную длину и не может быть изменен после создания. Значения элементов могут быть любыми целыми числами от 0 до 255 включительно. Каждый элемент bytes представляет один байт информации.
    
    Пример:
    
    ```python
    b = b'hello'# Создание объекта bytes
    print(b)# Вывод: b'hello'
    print(type(b))# Вывод: <class 'bytes'>
    ```
    
2. **bytearray**: Тип данных bytearray также представляет последовательность байтов, но в отличие от bytes, он является изменяемым. Это означает, что значения элементов bytearray могут быть изменены после создания. bytearray может быть использован для манипуляций с бинарными данными, такими как изменение или замена отдельных байтов.
    
    Пример:
    
    ```python
    ba = bytearray(b'hello')# Создание объекта bytearray
    print(ba)# Вывод: bytearray(b'hello')
    print(type(ba))# Вывод: <class 'bytearray'>
    ba[0] = 104# Изменение первого элемента
    print(ba)# Вывод: bytearray(b'h')
    ```
    
3. **memoryview**: Тип данных memoryview предоставляет возможность работать с данными, размещенными в памяти, как с последовательностью байтов. memoryview не создает новый объект, а предоставляет доступ к существующим данным в памяти. Это полезно для работы с большими объемами данных без копирования их в новые объекты.
    
    Пример:
    
    ```python
    b = b'hello'
    mv = memoryview(b)# Создание объекта memoryview
    print(mv)# Вывод: <memory at 0x...>
    print(type(mv))# Вывод: <class 'memoryview'>
    print(mv[1])# Вывод: 101 (код ASCII для символа 'e')
    ```
    

**Бинарные файлы**

Бинарный файл - это файл, содержащий данные в бинарном формате, то есть данные, представленные в виде последовательности байтов. Бинарные файлы используются для хранения и передачи данных, которые не являются текстом или требуют специальной обработки.

В Python для работы с бинарными файлами используется функция open() с параметром 'rb' (read binary) для чтения, и 'wb' (write binary) или 'ab' (append binary) для записи в файл.

Пример чтения из бинарного файла:

```python
pythonCopy code
with open('file.bin', 'rb') as f:
    data = f.read()
    print(data)
```

Пример записи в бинарный файл:

```python
pythonCopy code
data = b'hello'
with open('file.bin', 'wb') as f:
    f.write(data)
```

**Порядок байт, разрядность бинарных типов данных**

Порядок байт (byte order) относится к способу представления многобайтовых данных в памяти компьютера. Существуют два основных порядка байт: little-endian и big-endian.

- **Little-endian**: В этом порядке младший байт хранится в младшем адресе памяти, а старший байт - в старшем адресе. Например, число 0x1234 будет храниться как 0x34 в младшем адресе и 0x12 в старшем адресе.
- **Big-endian**: В этом порядке старший байт хранится в младшем адресе памяти, а младший байт - в старшем адресе. Например, число 0x1234 будет храниться как 0x12 в младшем адресе и 0x34 в старшем адресе.

Разрядность (bit depth) бинарных типов данных определяет количество битов, используемых для представления значения. Например, разрядность типа данных int в Python обычно составляет 32 бита или 64 бита, в зависимости от платформы.
