# 3. Модель памяти Python

Области видимости, время жизни объекта. Создание и удаление объектов.
Поверхностное и глубокое копирование. Слабые ссылки. Сборка мусора в
Python

**Области видимости:**

В Python существуют три области видимости переменных: локальная, глобальная и нелокальная. **local global и nonlocal.** 
**Приоритет поиска переменной** при выполнении кода такой: local → nonlocal → global → если не нашлась, то ошибка.

1. Локальная область видимости ограничена телом функции или метода. Переменные, объявленные внутри функции, являются локальными и доступны только внутри этой функции.
    
    Пример:
    
    ```python
    def my_function():
        x = 10# локальная переменная
        print(x)
    
    my_function()# Выводит 10
    print(x)# Ошибка: x не определена
    ```
    
2. Глобальная область видимости охватывает весь модуль или файл. Переменные, объявленные вне функций или классов, являются глобальными и доступны в любом месте модуля.
    
    Пример:
    
    ```python
    x = 10# глобальная переменная
    
    def my_function():
        print(x)
    
    my_function()# Выводит 10
    ```
    
3. Нелокальная область видимости возникает при использовании функций внутри других функций. Переменные, объявленные во внешней функции, но не являющиеся глобальными, могут быть доступны во внутренней функции.
    
    Пример: (Т.к. локальной переменной в inner нет, то он пошёл искать nonlocal)
    *Замечание* nonlocal не является global. Оно действует при функции в функции.
    
    ```python
    def outer_function():
        x = 10# нелокальная переменная
    
        def inner_function():
            print(x)
    
        inner_function()# Выводит 10
    
    outer_function()
    ```
    

**Время жизни объекта:**

Время жизни объекта в Python определяет период, в течение которого объект существует в памяти и может быть использован. Время жизни объекта начинается с его создания и завершается, когда объект больше не используется и память, которую он занимает, освобождается.

В Python объекты автоматически удаляются из памяти, когда на них больше нет ссылок. Сборка мусора автоматически освобождает память, занимаемую неиспользуемыми объектами.

**Создание и удаление объектов:**

Объекты в Python создаются с помощью оператора new или просто путем присваивания значения переменной. Удаление объектов происходит автоматически, когда на них больше нет ссылок, или с помощью оператора del.

Пример создания объекта:

```python
x = 10# создание объекта типа int
```

Пример удаления объекта:

```python
x = 10# создание объекта
del x# удаление объекта
```

**Поверхностное и глубокое копирование:**

В Python копирование объектов может быть поверхностным или глубоким.

1. Поверхностное копирование создает новый объект, но ссылается на те же вложенные объекты. Если изменить вложенный объект, то оно отразится и на скопированном объекте.
    
    Пример:
    
    ```python
    import copy
    
    list1 = [1, 2, [3, 4]]
    list2 = copy.copy(list1)
    
    list2[0] = 5
    list2[2][0] = 6
    
    print(list1)# Выводит [1, 2, [6, 4]]
    print(list2)# Выводит [5, 2, [6, 4]]
    ```
    
2. Глубокое копирование создает новый объект и рекурсивно копирует все вложенные объекты. Изменения в глубоко скопированном объекте не влияют на оригинал.
    
    Пример:
    
    ```python
    import copy
    
    list1 = [1, 2, [3, 4]]
    list2 = copy.deepcopy(list1)
    
    list2[0] = 5
    list2[2][0] = 6
    
    print(list1)# Выводит [1, 2, [3, 4]]
    print(list2)# Выводит [5, 2, [6, 4]]
    ```
    

**Слабые ссылки:**

Слабые ссылки (weak references) в Python позволяют ссылаться на объект, не увеличивая его счетчик ссылок. Они не предотвращают удаление объекта из памяти.

Слабые ссылки могут быть полезны, когда нужно отслеживать объекты, но не хотите влиять на их время жизни или предотвращать их удаление сборщиком мусора.

Пример:

```python
import weakref

class MyClass:
    pass

obj = MyClass()
ref = weakref.ref(obj)

print(ref())# Выводит <__main__.MyClass object at 0x7f9cf1a5a6d0>

del obj
print(ref())# Выводит None, так как объект удален из памяти
```

**Сборка мусора в Python:**

Сборка мусора в Python - это процесс автоматического освобождения памяти, занимаемой неиспользуемыми объектами. 

Если для какого-то объекта количество ссылок становится равным нулю, он немедленно уничтожается. Это схема отлично работает до тех пор, пока не появляются объекты, ссылающиеся друг на друга. Чтобы устранить такие циклические ссылки, в Питоне существует второй механизм освобождения памяти — **сборщик мусора**. Он запускается время от времени, ставя выполнение остального кода на паузу, и анализирует все неосвобожденные объекты.
