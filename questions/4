
Для открытия файла используется функция open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
Функция возвращает файловый объект. Обязателен только первый аргумент. Имя файла может быть абсолютным или относительным. Если остальные параметры отсутствуют, файл будет доступен на чтение. Таблица режимов (mode) функции open:
'r' – чтение. Если указанного файла нет - получим ошибку.
'w' – запись. Если файл с указанным именем уже существует, он будет перезаписан
'a' – добавление в конец
'b' – бинарный режим. Используется с ‘w’ или ‘r’. Добавляется пост-/суф-фиксом.
'r+' – чтение и запись.


Замечание: почему есть режим ‘r+’, если для чтения и записи можно использовать комбинацию ‘rw’? Python копирует режимы из функции open() языка C. ‘r+’ - это то, что использует C, и Python придерживался 40-летнего соглашения.


Третий параметр устанавливает размер буферизации при работе с файлом. По умолчанию он выключен, и чтение/запись идет напрямую с диска на диск. Если значение аргумента указано 1 - файл с построчной буферизацией, больше одного - процесс буферизации выполняется с указанным размером буфера. Отрицательное число - размер буфера будет равен системному.

2. Атрибуты объекта - появляются, как только файл был открыт и появился файловый объект:	

file.closed
Возвращает True если файл был закрыт.
file.mode
Возвращает режим доступа, с которым был открыт файл.
file.name
Возвращает имя файла.
file.softspace
Возвращает False, если при выводе содержимого файла следует отдельно добавлять пробел.


3. Для записи в файл используется метод write(). Записывает любую строку(или байты, в зависимости от режима) в открытый файл. Важно помнить, что строки в Python могут содержать двоичные данные, а не только текст.
Метод write() не добавляет символ переноса строки ('\n') в конец файла. Для этого можно использовать print(text, file=file) - добавится перевод строки или другой указанный разделитель.


4. Метод read() читает строку (байты) из открытого файла.


    my_file.read([count])

Необязательный параметр count - это количество байт, которые следует прочитать из открытого файла. Этот метод читает информацию с начала файла и, если параметр count не указан, до конца файла.
Для произвольного доступа к файлу есть функция seek:
seek(offset[, whence])
whence – по умолчанию равен нулю, указывает на то, что смещение берется относительно начала файла.
Есть три возможных значения для whence, которые определяют, относительно чего берётся смещение: начала файла (по умолчанию), текущей позиции, конца файла. Эти значения (числа 0, 1, 2) лежат в константах os.SEEK_...
offset – смещение в байтах.

Функция tell() возвращает текущую позицию файла.

Методы read() и readlines() загружают в память сразу весь файл. Их можно использовать при работе с небольшими файлами.
Для работы с потенциально большими файлами необходимо использовать вызовы
readline() и read(N)

5.Построчная работа с файлами. 
Прочитать одну строку:
 	file.readline()
Функция readline() без параметра читает всю строку, наличие параметра указывает функции максимальное число символов строки, которое будет прочитано.
Прочитать все строки и вернуть список строк:
 	file.readlines()
Записать строки в файл:
 file.writelines()

6. Закрытие файла. Для закрытия файла есть метод close(). Обычно файл закрывается сам после того, как вы выходите из программы, но файлы нужно закрывать вручную по нескольким причинам.
Питон может буферизировать запись в файл ваших данных, что может привести к неожиданным эффектам и возникновению ошибок.
У операционной системы есть ограничение на число одновременно открытых файлов.
При доступе к файлу из разных мест одновременно и на чтение, и на запись необходимо синхронизировать файловые операции. Буферизация записи может привести к тому, что запись уже произошла, а данных в файле еще нет.
Для полной уверенности в закрытии файла можно использовать блок try/finally:
try:
    # Тут идет запись в файл
finally:
    file.close()

Для работы с файлом рекомендуется использовать менеджер контекста, который в любом случае закроет файл:
with open("my_file") as somefile:
    do_something(somefile)

Кодировки
Исходный код
Файлы исходного кода должны использовать UTF-8, если же есть необходимость сохранить файл в другой кодировке - используется специальный комментарий в начале файла.
# -*- coding: <имя кодировки> -*-


Строки
По умолчанию в python3 используется кодировка UTF-8, все объекты str хранятся в этой кодировке. Нестандартные символы могут быть заданы экранирующими последовательностями:
"\u0394" # Используем 16-битное значение
"\U00000394" # Используем 32-битное значение


Еще один способ создать строку - метод decode() объекта bytes. В качестве аргумента он принимает кодировку:
s1 = b'\x80abc'.decode("utf-8")  # 'abc'


Кодировка задается в виде предопределенной строки. Python 3 поддерживает около 100 кодировок.
Обратный метод преобразования, str.encode() возвращает объект bytes - представление строки в виде байтов с учетом конкретной кодировки. Принимает те же аргументы на вход, что и decode().

Кодировки
Исходный код
Файлы исходного кода должны использовать UTF-8, если же есть необходимость сохранить файл в другой кодировке - используется специальный комментарий в начале файла.
# -*- coding: <имя кодировки> -*-


Строки
По умолчанию в python3 используется кодировка UTF-8, все объекты str хранятся в этой кодировке. Нестандартные символы могут быть заданы экранирующими последовательностями:
"\u0394" # Используем 16-битное значение
"\U00000394" # Используем 32-битное значение


Еще один способ создать строку - метод decode() объекта bytes. В качестве аргумента он принимает кодировку:
s1 = b'\x80abc'.decode("utf-8")  # 'abc'


Кодировка задается в виде предопределенной строки. Python 3 поддерживает около 100 кодировок.
Обратный метод преобразования, str.encode() возвращает объект bytes - представление строки в виде байтов с учетом конкретной кодировки. Принимает те же аргументы на вход, что и decode().


Регулярные выражения предназначены для выполнения сложного поиска или замены в строке. В Python для них предусмотрен модуль re. Регвыр представляет собой строку, состоящую из специальных символов, модификаторов, квантификаторов.
Синтаксис
Внутри регвыра символы ., ^, $, *, +, ?, {, [, ], \, |, (, ) имеют специальное значение. Их следует экранировать с помощью слэша. 
[...] - в квадратных скобках можно указать символы, которые могут встречаться на этом месте в строке. Можно перечислять символы подряд или указать диапазон через тире.
Например, [а-яА-ЯёЁ] соответствует любой русской букве («ё» и «Ё» не входят в диапазоны [а-я] и [А-Я] соответственно.)
Можно указать символы, которых не должно быть на этом месте в строке. Для этого используется ^ сразу после открывающейся квадратной скобки (например, [^0-9] — не цифра от 0 до 9).
^ - привязка к началу строки или подстроки.
$ - привязка к концу строки или подстроки.
{...}  - квантификаторы - количество вхождений символа в строку. 
{n} — n вхождений символа в строку.
{n,} - n или более вхождений символа в строку.
{n,m} — не менее n и не более m вхождений символа в строку.
* - ноль или более вхождений.
+ - одно или большее число вхождений.
? - ни одного или одно вхождение символа.
Все квантификаторы — жадные (ищется самая длинная подстрока). Чтобы ограничить жадность, необходимо после квантификатора указать символ ?.
Стандартные классы:
\d — любая цифра.
\w — любая цифра, буква или символ подчеркивания.
\s — любой пробельный символ.
\D — не цифра.
\W — не буква, не цифра и не символ подчеркивания.
\S — не пробельный символ.
(...) - Круглые скобки часто используются для группировки фрагментов внутри шаблона. Чтобы избежать захвата фрагмента, следует после открывающейся круглой скобки разместить символы ?: . К найденному фрагменту в круглых скобках внутри шаблона можно обратиться с помощью механизма обратных ссылок. Для этого порядковый номер круглых скобок указывается после слэша, например, \1. Нумерация скобок начинается с 1.
	Существует также возможность сравнения шаблона с предыдущими и последующими символами:
(?=...) - положительный просмотр вперед.
Matches if ... matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it’s followed by 'Asimov'.

(?!...) - отрицательный просмотр вперед.
Matches if ... doesn’t match next. This is a negative lookahead assertion. For example, Isaac (?!Asimov)will match 'Isaac ' only if it’s not followed by 'Asimov'.
(?<=...) - положительный просмотр назад.
(?<!...) - отрицательный просмотр назад. 
Требуется, чтобы шаблоны, используемые при просмотре назад, имели фиксированную длину. Т.е. , к примеру, можно использовать (?<=[,]), но нельзя использовать (?<=[,]+).
]
Методы
compile() - создание откомпилированного шаблона регулярного выражения. re.compile при обработке больших объемов однотипных данных дает небольшой прирост в производительности и код за счет него получается читабельнее.
Формат: re.compile(регвыр, модификатор)
Поиск первого совпадения с шаблоном:
match() - проверяет соответствие с началом строки. Возвращает объект Match, если найдено соответствие. Иначе — None. 
search() - проверяет соответствие с любой частью строки. Возвращает объект Match, если найдено соответствие. Иначе — None.

Методы объекта Match:
group(group1, group2, …,groupN) - возвращает фрагменты, соответствующие шаблону.  Если параметр не задан или указано значение 0, то возвращается фрагмент, полностью совпадающий с шаблоном. 
groups(default_value) - возвращает кортеж, содержащий значения всех групп. С помощью параметра можно указать значение, которое будет выводиться вместо None для групп, не имеющих совпадений.
start(group_number_or_group_name) -  индекс начала фрагмента.
end(group_number_or_group_name) - индекс конца фрагмента.
span(group_number_or_group_name) -  кортеж, содержащий начальный и конечный индексы фрагмента.  

Поиск всех совпадений с шаблоном:
findall()- если соответствия найдены, то возвращается список с фрагментами(иначе пустой список). Если внутри шаблона более одной группы, то каждый элемент списка будет кортежем, а не строкой.  
finditer()- аналогичен findall(), но возвращает итератор, а не список. В каждой итерации цикла возвращается объект Match.

Форматы использования match() search() findall() finditer() :
regexp_object.method_name(string,start_position,end_position)
re.method_name(regexp, string, modificator)

Замена в строке:
sub() - поиск всех совпадений с шаблоном и замена их указанным значением.
subn() - аналогичен sub(), но возвращает не строку, а кортеж из двух элементов - измененной строки и количества произведенных замен.

Форматы методов sub() и subn():
regexp_object.method_name(new_fragment, replacement string, max replacement count)
re.method_name(template, new_fragment, replacement string, max replacement count)

Символ 'r' перед регулярным выражением указывает, что ничего в строке не должно быть экранировано. Для поиска символа '\'необходимо использовать четыре символа '\'в регвыре без 'r', тогда как с 'r' понадобится два символа '\'.


Некоторые другие методы:
re.split(pattern, string, maxsplit=0, flags=0)
# Разделить строку по вхождению шаблона. Если в шаблоне используются захватывающие скобки, то текст всех групп в шаблоне также возвращается как часть результирующего списка. Если maxsplit не равен нулю, происходит максимальное расщепление maxsplit, а остаток строки возвращается как последний элемент списка

>>> re.split(r'\W+', 'Words, words, words.')
['Words', 'words', 'words', '']
>>> re.split(r'(\W+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
>>> re.split(r'\W+', 'Words, words, words.', 1)
['Words', 'words, words.']
>>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
['0', '3', '9']

re.escape(pattern)
# Экранирует специальные символы в шаблоне

>>> print(re.escape('python.exe'))
python\.exe

>>> legal_chars = string.ascii_lowercase + string.digits + "!#$%&'*+-.^_`|~:"
>>> print('[%s]+' % re.escape(legal_chars))
[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&'\*\+\-\.\^_`\|\~:]+

>>> operators = ['+', '-', '*', '/', '**']
>>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))
/|\-|\+|\*\*|\*

>>> mo = re.search(r"(?P<user>\S+)@(?P<domain>\S+)", "d.v.kornev@gmail.com")
>>> print(mo.groupdict())
{'domain': 'gmail.com', 'user': 'd.v.kornev'}

import re

result = re.search(r'(?P<login>[0-9a-zA-Z.]+)@(?P<domain>[0-9a-zA-Z.]+)',
'My email is a.v.makarov@gmail.com')
print(type(result)) # <class '_sre.SRE_Match'>
print(result.group()) # a.v.makarov@gmail.com
print(result.group(0)) # a.v.makarov@gmail.com
print(result.group('login')) # a.v.makarov
print(result.group(1)) # a.v.makarov
print(result.group('domain')) # gmail.com
print(result.group(2)) # gmail.com

>>> m = re.search('(?<=abc)def', 'abcdef')
>>> m.group(0) # 'def'

>>> m = re.search(r'(?<=-)\w+', 'spam-egg')
>>> m.group(0) # 'egg'

Флаги компиляции
Существует 7 флагов компиляции, которые содержатся в Python 3. Эти флаги могут изменить поведение вашего паттерна. 


re.A / re.ASCII - указывает на сопоставление ASCII, вместо использования полного Юникода для сопоставления, в сочетании со следующими кодами: w, W, b, B, d, D, s и S. Также есть re.U / re.UNICODE, который используется в целях обратной совместимости. В любом случае, эти флаги являются излишеством, так как Python выполняет сопоставления в Юникоде в автоматическом режиме.
re.DEBUG - данный флаг показывает информацию о дебаге вашего скомпилированного выражения.
re.I / re.IGNORECASE - если вам нужно выполнить сравнение без учета регистра, тогда этот флаг – то, что вам нужно. Если ваше выражение было [a-z] и вы скомпилировали его при помощи этого флага, то ваш паттерн сопоставит заглавные буквы в том числе. Это также работает для Юникода и не влияет на текущую локаль.
re.L / re.LOCALE - данный флаг делает коды: w, W, b, B, d, D, s и S зависимыми от нынешней локали. Однако, в документации говорится, что вы не должны зависеть от данного флага, так как механизм локали сам по себе очень ненадежный. Вместо этого, лучше используйте сопоставление Юникода. Далее в документации говорится, что данный флаг имеет смысл использовать только в битовых паттернах.
re.M / re.MULTILINE - когда вы используете данный флаг, вы говорите Python, чтобы он использовал символ паттерна ^ для начала строки, и начало каждой линии. Он также указывает Python, что $ должен сопоставить конец каждой строки и конец каждой линии, что не сильно отличается от их значений по умолчанию.
re.S / re.DOTALL - этот забавный флаг указывает метасимволу «.» (период) сопоставить любой символ. Без этого флага, данный метасимвол будет сопоставлять все, что угодно, но не новую строку (\n).
re.X / re.VERBOSE - если вы считаете, что ваши регулярные выражения не слишком читабельные, тогда данный флаг – это то, что вам нужно. Он позволяет визуально разделять логические секции ваших регулярных выражений, и даже добавлять комментарии! Пустое пространство внутри паттерна будет игнорироваться, кроме того случая, если классу символа или пробелу предшествует обратная косая черта.

Строки лучше брать из первого билета

