Всё есть объект. Классы являются объектами.
Чтобы программную сущность можно было считать объектом, необходимы как минимум два поля, определённые в структуре: счетчик ссылок и тип.
Счётчик ссылок — это число, показывающее, сколько раз другие объекты ссылаются на данный. Если для какого-то объекта счетчик становится равным нулю, он немедленно уничтожается. Это схема отлично работает до тех пор, пока не появляются объекты, ссылающиеся друг на друга. Чтобы устранить такие циклические ссылки, в Питоне существует второй механизм освобождения памяти — сборщик мусора. Он запускается время от времени, ставя выполнение остального кода на паузу, и анализирует все неосвобожденные объекты.


Класс — это объект, включающий набор переменных и функций для управления этими переменными. Переменные называются атрибутами, а функции — методами. Это в основном оболочка для содержимого пространства имен, созданного определением класса. Объекты класса поддерживают два вида операций: ссылки на атрибуты и создание экземпляров.

Методы:
 __name__ - имя класса
__module__ - модуль класса
__dict__ - словарь имен класса
__bases__ - кортеж с предками


Определения классов должны быть выполнены до того, как они окажут какое-либо влияние (можно разместить определение класса в ветви оператора if или внутри bhфункции). Класс описывается по следующей схеме:
class MyClass(base_class1, base_class2...base_classN):
    i = 0
    
    def f(*parameters):
        pass

Вышеописанная инструкция создает новый объект (класс) и присваивает ссылку на него идентификатору, указанному после ключевого слова class, в данном случае идентификатор - MyClass. Выражения внутри инструкции class выполнятся при создании класса, а не при создании экземпляра класса. Класс создаётся при считывании программного модуля.


Ссылки на атрибуты используют стандартный синтаксис, используемый для всех ссылок на атрибуты в Python: obj.name. Допустимые имена атрибутов - это все имена, которые были в пространстве имен класса при создании объекта класса. В примере выше MyClass.i и MyClass.f являются действительными ссылками на атрибуты, возвращая целое число и объект функции, соответственно. Ссылки на атрибуты класса транслируются в его словарь, то есть C.x -> C.__dict__[‘x’]


 Атрибуты класса также могут быть назначены, так что можно изменить значение MyClass.. __doc__ также является допустимым атрибутом, возвращающим строку документации, принадлежащую классу: «A simple example class». Все атрибуты класса открытые (public). Атрибуты можно создавать динамически после создания класса. 
    
Важно понимать разницу между атрибутами объекта класса и атрибутами экземпляра класса. Атрибут объекта класса доступен всем экземплярам класса, но после изменения атрибута значение изменится во всех экземплярах класса. Атрибут экземпляра класса может хранить уникальное значение для каждого экземпляра и изменение такого атрибута не затронет значение одноименного атрибута в других экземплярах.


Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.
Одиночное подчеркивание в начале имени атрибута говорит о том, что переменная или метод не предназначен для использования вне методов класса, однако атрибут доступен по этому имени. Все, что использует такой способ задания имени, будет проигнорировано в from module import *. 
Два или более подчеркивания в начале имени атрибута(при этом в конце имени не должно быть более одного подчеркивания) дают большую защиту: атрибут становится недоступным по этому имени. Однако полностью это не защищает, так как атрибут всё равно остаётся доступным. 
class A:
    def _hello(self):
        print("_hello")
a = A()
a._hello() # Output: "_hello"
class B:
    def __hello(self):
        print("__hello")
b = B()
b.__hello() # Output: AttributeError: 'B' object has no attribute "__hello"
b._B__hello() # Output: "__hello"

Два подчеркивания в начале и в конце имени атрибута используются для специальных свойств и функций класса (например, для перегрузки операции). Такие атрибуты доступны по своему имени, но их использование зарезервировано для специальных атрибутов, изменяющих поведение объекта.
Cтоит упомянуть о том, что можно переопределять методы сложения экземпляров класса, равенства и др.. (def __div__(self, *args):, def __eq__(self, *args):, etc.)

Создание экземпляра класса использует такое же обозначение, как создание функций.
x = MyClass()

создает новый экземпляр класса и назначает этот объект локальной переменной x.


Операция создания экземпляра («вызов» объекта класса) создает пустой объект. 
Многие классы любят создавать объекты с экземплярами, настроенными на конкретное начальное состояние. Поэтому класс может определять специальный метод с именем __init __(), с помощью которого можно присвоить начальные значения атрибутам класса. Когда класс определяет метод __init __(), создание экземпляра класса автоматически вызывает __init __() для вновь созданного экземпляра класса. 
Единственные операции, понятные экземплярам класса, это ссылки на атрибуты данных и методов.


Перед уничтожением объекта автоматически вызывается метод __del__(). Метод не будет вызван, если на экземпляр класса существует хотя бы одна ссылка.


Переопределив классовый метод __new__, можно контролировать процесс создания экземпляра. Этот метод вызывается до метода __init__ и должен вернуть новый экземпляр, либо None. Метод __new__ используется для управления созданием неизменчивых (immutable) объектов, управления созданием объектов в случаях, когда __init__ не вызывается, например, при десериализации (unpickle).

class Singleton(object):
    obj = None # Атрибут для хранения единственного экземпляра
    def __new__(cls,*dt,**mp): # класса Singleton.
        if cls.obj is None: # Если он еще не создан, то
           cls.obj = object.__new__(cls,*dt,**mp) # вызовем __new__ предка                      
        return cls.obj # вернем синглтон

obj = Singleton()
obj.attr = 12
new_obj = Singleton()
new_obj is obj # new_obj и obj - это один и тот ж,0е объект



Метод __call__ вызывается при обращении к экземпляру как к функции. Если метод __call__ присутствует, интерпретатор будет вызвать его, когда экземпляр вызывается как функция, передавая ему любые позиционные и именованные аргументы. Все, что передается экземпляру, передается этому методу наряду с обычным аргументом self, в котором передается сам экземпляр. 
class C:
    def __call__(self, a, b, x=50, y=60): # Обычные и со значениями по умолчанию
        pass
 
class C:
    def __call__(self, *args, **kwargs): # Произвольные аргументы
        pass
 
class C:
    def __call__(self, *args, x = 100, **kwargs): # Аргументы которые могут
        pass                                      # передаваться только по имени


X = C()                        
X(1, 2)                        # Аргументы со значениями по умолчанию опущены
X(1, 2, 3, 4)                  # Позиционные
X(a = 10, b = 20, c = 30)      # Именованные
X(*[1, 2], **dict(c=3, d=4))   # Распаковывание произвольных аргументов
X(1, *(2,), c=3, **dict(d=4))  # Смешанные режимы

Реализация операции вызова, как в данном примере, позволяет экземплярам классов имитировать поведение функций, а также сохранять информацию о состоянии между вызовами:
>>> class Prod:
        def __init__(self, value): 
         	self.value = value
        def __call__(self, other):
         	return self.value * other
>>> X = Prod(3) 
>>> X(3)       
9
>>> X(4)
12


class Factorial:
    def __init__(self): 	# Конструктор не принимает аргументов
        self.cache = {} 	# Создаем пустой словарь для кэша
    def __call__(self, n):
        if n not in self.cache:
            if n == 0:
                self.cache[n] = 1
            else:
                self.cache[n] = n * self.__call__(n - 1) # Рекурсия!
        return self.cache[n]

Наследование, mro
Наследование — механизм языка, позволяющий описать новый класс на основе нескольких уже существующих (родительских, базовых) классов. Класс-потомок может добавить собственные методы и свойства, а также пользоваться родительскими методами и свойствами. Позволяет строить иерархии классов.

Предположим есть класс А. При помощи наследования мы можем создать новый класс В, в котором будет доступ ко всем атрибутам и методам класса А, а также к некоторым новым атрибутам и методам. Класс А указывается внутри круглых скобок в определении класса B (по имени либо через другой модуль). 
Класс А называется базовым классом или суперклассом, а класс B — произвольным классом или подклассом. 
Если имя метода в классе В совпадает с именем метода в классе А, то будет использоваться метод из класса В. Чтобы вызвать одноименный метод из базового класса, следует указать перед методом название базового класса, а в первом параметре необходимо явно указать ссылку на экземпляр класса;  либо воспользоваться функцией super(). 

Выполнение определения производного класса происходит так же, как и для базового класса. Когда объект класса создан, базовый класс запоминается.
Разрешение ссылок на атрибуты: если запрошенный атрибут не найден в классе, поиск переходит к поиску в базовом классе. Это правило применяется рекурсивно (если сам базовый класс является производным). Если несколько родителей, то сначала рекурсивно в первом, затем во втором и т.д.
Разрешение ссылок на методы: поиск соответствующего атрибута класса осуществляется по цепочке базовых классов, если необходимо, и ссылка на метод действительна, если это приводит к функциональному объекту.


Переопределяющий метод в производном классе может фактически расширить, а не просто заменить метод базового класса с тем же именем. Прямой вызов метода базового класса работает, только если базовый класс доступен в глобальной области.
Встроенные типы могут использоваться пользователем в качестве базовых классов для наследования.
В Python есть две встроенные функции, которые работают с наследованием:
- isinstance(), чтобы проверить тип экземпляра: isinstance (obj, int) будет иметь значение True только в том случае, если obj .__ class__ равен int или некоторый класс получен из int.
- issubclass() для проверки наследования классов: issubclass (bool, int) имеет значение True, поскольку bool является подклассом int. Однако issubclass (float, int) имеет значение False, поскольку float не является подклассом int.
Порядок разрешения методов изменяется динамически для поддержки совместных вызовов super().
Динамическое упорядочение необходимо, потому что во всех случаях множественного наследования проявляется одна или несколько алмазных связей (где по крайней мере один из родительских классов может быть доступен через несколько путей из самого нижнего класса). Например, все классы наследуются от объекта, поэтому любой случай множественного наследования предоставляет более одного пути для достижения объекта. Чтобы предотвратить доступ к базовым классам более одного раза, динамический алгоритм линеаризует порядок поиска таким образом, чтобы сохранить порядок слева направо, указанный в каждом классе, который вызывает каждого родителя только один раз, и это монотонно (это означает, что класс может быть разделен на подклассы, не затрагивая порядок приоритета его родителей). Взятые вместе, эти свойства позволяют создавать надежные и расширяемые классы с множественным наследованием.
MRO - Method Resolution Order – порядок разрешения методов.
Дан класс C в сложной иерархии множественного наследования, нетривиальная задача - указать порядок, в котором методы переопределяются, то есть указать порядок предков C.
Список предков класса C, включая сам класс, упорядоченный от ближайшего предка к самому дальнему, называется списком приоритетов класса или линеаризацией C.
Порядок разрешения методов (MRO) - это набор правил, которые строят линеаризацию. В литературе по Python идиома «MRO of C» также используется как синоним линеаризации класса C.
Например, в случае иерархии с единым наследованием, если C является подклассом C1, а C1 является подклассом C2, то линеаризация C является просто списком [C, C1, C2]. Однако в случае множественных иерархий наследования построение линеаризации является более громоздким, поскольку сложнее построить линеаризацию, которая учитывает локальный порядок приоритетов и монотонность.
MRO является монотонным, если верно следующее: если C1 предшествует C2 в линеаризации C, то C1 предшествует C2 в линеаризации любого подкласса C. В противном случае безобидная операция получения нового класса может изменить порядок разрешения методов, потенциально представляя очень тонкие ошибки. Примеры, где это происходит, будут показаны позже.
Не все классы допускают линеаризацию. В сложных иерархиях бывают случаи, когда невозможно получить класс, чтобы его линеаризация учитывала все требуемые свойства.
Порядок разрешения методов C3:
Обозначения: C1 C2 ... CN - список классов [C1, C2, ..., CN], head = C1 – первый элемент списка, tail = C2 ... CN – остальная часть списка, C + (C1 C2 ... CN) = C C1 C2 ... CN - сумма списков [C] + [C1, C2, ..., CN].
Рассмотрим класс C в иерархии множественного наследования, где C наследуется от базовых классов B1, B2, ..., BN. Мы хотим вычислить линеаризацию L [C] класса C. Правило следующее:
Линеаризация C - это сумма C плюс слияние линеаризаций родителей и списка родителей. L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)
В частности, если C является классом, у которого нет родителей, линеаризация тривиальна: L[object] = object.
Тем не менее, в общем случае необходимо рассчитать слияние согласно следующему предписанию:
Взять head первого списка, т. е. L [B1] [0]; если этот head не находится в tail любого из других списков, то добавить его к линеаризации C и удалить его из списков в слиянии, в противном случае посмотрите на head следующего списка и возьмите его, если это хороший head. Затем повторять операцию, пока все классы не будут удалены или невозможно найти хороший head. В этом случае невозможно построить слияние.
Вычисление слияния является тривиальным, если C имеет только одного родителя (одиночное наследование); в этом случае L[C(B)] = C + merge(L[B],B) = C + L[B].


Примеры можно посмотреть тут -> https://www.python.org/download/releases/2.3/mro/ (эта ссылка была в документации питона версии 3.7.2)
