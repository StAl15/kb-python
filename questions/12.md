Тесты проверяют работоспособность кода и немного вас успокаивают. В тех случаях, для которых вы тесты написали, можно быть уверенным, что код работает — если, конечно, вы его нормально написали. Сон крепче. Это очень важно. 
Тесты проверяют исполнение контрактов поведения кода. Поясню. У вас есть код, который в краевых или редких условиях, в непонятных кейсах, должен вести себя определенным образом. Вы это обговорили с заказчиком, или это написано в ТЗ. В любом случае вы договорились, что код должен вести себя именно так.
Тесты позволяют проверять взаимодействие старого и нового кода. Представим ситуацию, как в предыдущем пункте. У вас есть код, он работает. Пришел человек, написал новый код, захотел использовать кусочек старого. Что-то куда-то вынес, что-то где-то поправил. На случай, если он сломал существующую функциональность, хорошо бы иметь тесты, которые тоже сломаются. Иначе вы можете обнаружить это в продакшене в какой-нибудь очень неприятный момент. 
Тесты поощряют написание кода слабого зацепления, когда ваш код распадается на отдельные обособленные кусочки. Почему это связано с тестированием? Если у вас есть одна функция с кучей параметров, которая написана простыней на четыре экрана, то вы на нее посмотрите и, скорее всего, подумаете: писать тест на эту функцию неудобно, придется кучу всего передать. Возникает 500 тест-кейсов, у вас голова разрывается. Разбейте огромную функцию на много маленьких и протестируйте каждую в отдельности. Это намного проще и заодно сделает код более читаемым.
Системное тестирование – тестирование полностью интегрированного программного приложения 
Интеграционное тестирование – тестирование интегрированных групп программных модулей 
Модульное тестирование или юнит-тестирование – тестирование отдельных модулей исходного кода приложения
Модульное тестирование 
Модульное тестирование, или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. 
 
Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже протестированных местах программы и облегчает обнаружение и устранение таких ошибок.
Интеграционное тестирование 
Интеграцио́нное тестирование или функциональное тестирование предназначено для проверки связи между компонентами, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). 
 
Подходы к интеграционному тестированию 
Снизу вверх (Bottom Up Integration) 
Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули разрабатываемого уровня готовы. 
Сверху вниз (Top Down Integration) 
Вначале тестируются все высокоуровневые модули, и постепенно, один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. 
Большой взрыв ("Big Bang" Integration) 
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако, если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования
Системное тестирование 
Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты: 
 
Неверное использование ресурсов системы 
Непредусмотренные комбинации данных пользовательского уровня 
Несовместимость с окружением 
Непредусмотренные сценарии использования 
Отсутствующая или неверная функциональность 
Неудобство использования 
И другие 
Для минимизации рисков, связанных с особенностями поведения в системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи. 
 
Стоит выделить два подхода к системному тестированию: 
 
на базе требований (requirements based). Для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования. 
на базе случаев использования (use case based). На основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся тест кейсы (test cases), которые реализуются в виде тестов.
Assert — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. 
 
Assert'ы позволяют отлавливать ошибки в программах на этапе компиляции либо во время исполнения. 
 
Использование конструкции весьма простое: 
 
# -*- encoding: utf-8 -*- 
 
def simple_func(value): 
    assert type(value) == int 
    assert value > 0 
 
    return value*value 
Assert вызывает ошибку, если аргумент равен False. Например так: 
 
>>> print(simple_func(2)) 
4 
>>> print(simple_func(set())) 
Traceback (most recent call last): 
  File "/tmp/testing/app.py", line 11, in <module> 
    print(simple_func(set())) 
  File "/tmp/testing/app.py", line 4, in simple_func 
    assert type(value) == int 
AssertionError 
>>> 
>>> print(simple_func(-1)) 
Traceback (most recent call last): 
  File "/tmp/testing/app.py", line 21, in <module> 
    print(simple_func(-1)) 
  File "/tmp/testing/app.py", line 5, in simple_func 
    assert value > 0 
AssertionError 
Traceback показывает строчку, с которой полетело исключение AssertionError, что порой открывает много нового в понимании, как же в реальности работает написанный код.
Для чего нужно снимать метрики 
Метрики тестирования используются для отслеживания усилий по обеспечению качества выпускаемого программного кода. С их помощью удаётся в численном выражении получить представлении о достижении заданного уровня качества или поставленных целей. Визуальное представление результатов формирует наглядную картину процесса тестирования, которая может показать узкие места. 
 
В процессе тестирования метрики используются: 
 
для отслеживания прогресса команды по срокам проекта, дедлайнам и другим временным отрезкам; 
 
качественной оценки текущего состояния системы; 
 
контроля качества процесса тестирования; 
 
постановки целей и эффективного планирования исходя из понимания существующих проблем. 
 
Останавливаться на текущем качестве функционирования системы и, что более важно, процессов не следует. Именно эти характеристики являются базой для роста эффективности команды и результатных показателей. Рациональность использования человеческого ресурса напрямую завязана на общей производительности. Обидно иметь в команде специалиста, потенциал которого не реализован и на 50%. За такую невнимательность вполне можно заработать не самые приятные бонусы, вплоть до потери репутации и денег. 
 
Какие метрики чаще всего упоминаются в статьях по тестированию 
При тестировании на проектах можно выделить ряд метрик, которые чаще всего упоминаются в большинстве обучающих курсов и статей. 
 
Passed/Failed Test Cases. Используется для оценки отношения удачно пройденных тестов к завершившимся с ошибками. Метрика помогает оценить успешность прохождения тестов. 
 
Not Run Test Cases. Демонстрирует количество тестов, которые нужно выполнить для данного проекта. Метрика помогает определить причины невыполнения тестов и способы их устранения. 
 
Open/Closed Bugs. Формируется из отношения открытых багов к закрытым. Метрика оценивает скорость устранения багов, а также позволяет выявить причины, по которым ошибки остались незакрытыми. 
 
Reopened/Closed Bugs. Рассчитывает соотношение переоткрытых багов к закрытым. Метрика демонстрирует эффективность закрытия бага разработчиками и поможет выявить причины, по которым исправление ошибок находится на низком уровне. 
 
Bugs by Severity/Priority. Общее количество багов по серьёзности/приоритету. Метрика показывает качество предоставляемого кода на тестирование
