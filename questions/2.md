# 2. Объектная модель Python

«Всё есть объект», type. Классы. Атрибуты объектов, классов. Методы.
Статические и классовые методы. Наследование. Интроспекция.

- словари,

Всё в Питоне — **объект**:

- числа,
- пользовательские и встроенные классы.

Чтобы программную сущность можно было считать объектом, необходимы как минимум два поля, определённые в структуре:

- счетчик ссылок
- тип.

**Счётчик ссылок** — это число, показывающее, сколько раз другие объекты ссылаются на данный. В коде

```python
a = object()
b = a
c = b
```

инициализируется пустой объект и связывается с тремя разными именами: a, b и c. Каждое имя создаёт новую ссылку на объект, но при этом объект создаётся **единожды.**

Если для какого-то объекта количество ссылок становится равным нулю, он немедленно уничтожается. Это схема отлично работает до тех пор, пока не появляются объекты, ссылающиеся друг на друга. Чтобы устранить такие циклические ссылки, в Питоне существует второй механизм освобождения памяти — **сборщик мусора**. Он запускается время от времени, ставя выполнение остального кода на паузу, и анализирует все неосвобожденные объекты.

```python
# Пример объекта строки
my_string = "Привет, мир!"
```

**Функция type()** используется для получения типа объекта.

```python
x = 5
print(type(x))# Выводит <class 'int'>, что означает, что x является объектом типа int (целое число)

y = "Hello, World!"
print(type(y))# Выводит <class 'str'>, что означает, что y является объектом типа str
```

**Класс** — это объект, включающий набор переменных и функций для управления этими переменными. Переменные называются атрибутами, а функции — методами. Класс является фабрикой объектов, т.е. позволяет создать неограниченное количество экземпляров, основанных на этом классе. 
Методам класса в первом параметре автоматически передается ссылка на экземпляр класса(общепринято называть ***self***). Доступ к атрибутам и методам класса производится через переменную self с помощью точечной нотации.

**Методы __init__(), __del__()**

При создании экземпляра класса автоматически вызывается метод инициализации *__init__()*. С помощью метода *__init__()* можно присвоить начальные значения атрибутам класса. При создании экземпляра класса начальные значения указываются после имени класса в круглых скобках.

Перед уничтожением объекта автоматически вызывается метод

*__del__()*

Метод не будет вызван, если на экземпляр класса существует хотя бы одна ссылка.

```python
# Пример определения класса
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет!")

# Создание объекта класса Person
person = Person("Иван", 30)
person.greet()# Выводит "Привет, меня зовут Иван и мне 30 лет!"
```

**Атрибуты объектов и классов:** Атрибуты представляют данные, связанные с объектами или классами. Атрибуты объектов уникальны для каждого экземпляра, тогда как атрибуты класса общие для всех экземпляров класса. Атрибуты могут быть установлены и получены с использованием точечной нотации.

```python
# Пример атрибутов объектов и классов
class Car:
    color = "Red"# Атрибут класса

    def __init__(self, brand, model):
        self.brand = brand# Атрибут объекта
        self.model = model# Атрибут объекта
# Создание объекта класса Car
my_car = Car("Toyota", "Corolla")
print(my_car.brand)# Выводит "Toyota"
print(my_car.model)# Выводит "Corolla"
print(my_car.color)# Выводит "Red" (атрибут класса)
```

**Методы:** Методы представляют функции, связанные с объектами или классами. Они определяют поведение объектов и могут быть вызваны на объектах с использованием точечной нотации. Методы могут иметь доступ к атрибутам объекта и класса.

```python
# Пример методов объектов и классов
class Circle:
    pi = 3.14159# Атрибут класса

    def __init__(self, radius):
        self.radius = radius# Атрибут объекта

    def area(self):
        return self.pi * self.radius ** 2# Метод объекта

    @staticmethod
    def circumference(radius):
        return 2 * Circle.pi * radius# Статический метод класса
# Создание объекта класса Circle
my_circle = Circle(5)
print(my_circle.area())# Выводит площадь круга
print(Circle.circumference(5))# Выводит длину окружности (статический метод класса)
```

**Статические и классовые методы:** Статические методы и классовые методы - это методы, которые могут быть вызваны без создания экземпляра класса. Они часто используются для выполнения операций, не требующих доступа к атрибутам объекта.

**Декоратор** в питоне представляет собой функцию, которая может изменить поведение другой функции. Это возможно, потому что функции в питоне являются объектами, и их можно передавать в качестве аргументов и возвращать в качестве результатов другой функции.

**Статические методы** могут быть определены с помощью **декоратора @staticmethod** и не требуют первого аргумента self. Они могут быть вызваны как на объектах, так и на классах.

**Классовые методы** могут быть определены с помощью **декоратора @classmethod** и принимают первым аргументом класс (обычно обозначается как cls). Они также могут быть вызваны как на объектах, так и на классах, и могут использоваться для создания или возвращения новых экземпляров класса.

```python
# Пример статического и классового методов
class MathUtils:
    @staticmethod
    def add(x, y):
        return x + y

    @classmethod
    def multiply(cls, x, y):
        return cls.add(x, y) * 2

print(MathUtils.add(2, 3))# Выводит 5 (статический метод)
print(MathUtils.multiply(2, 3))# Выводит 10 (классовый метод)
```

**Наследование:** Наследование в Python позволяет создавать новые классы на основе уже существующих. Класс, от которого происходит наследование, называется базовым классом, а класс, который наследует свойства и методы базового класса, называется производным классом или подклассом. Подкласс может добавлять новые атрибуты и методы или переопределять существующие.

Можно также воспользоваться функцией super() для доступа к полям базового класса:
super().method()
super().attrib
*Примечание:* Конструктор базового класса автоматически не вызывается, если он переопределен в производном классе.

Метод **is** не работает на наследование, то есть 
a=class (A)  b = class(B), где B наследуется от A.
То при использовании b is a нам выдаст **False**. 
a is A Выдаст **True**

`print(класс.__mro__)` даст нам порядок, в котором будут просматриваться методы класса при вызове. Например: (<class '**main**.B'>, <class '**main**.A'>, <class 'object'>) То есть сначала класс, откуда вызываем, затем родительский, затем в object, если не нашли нигде этого метода то генерируется ошибка **type object 'имя класса' has no attribute 'имя метода’**

```python
# Пример наследования
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("Животное издает звук")

class Dog(Animal):
    def speak(self):
        print("Собака лает")

animal = Animal("Животное")
animal.speak()# Выводит "Животное издает звук"

dog = Dog("Бобик")
dog.speak()# Выводит "Собака лает"
```

**Интроспекция:** Интроспекция в Python - это возможность получать информацию о классах, объектах, модулях и т.д. во время выполнения программы. Встроенные функции dir() и type() используются для получения информации об объектах.
