### Процессы. Мультипроцессинг в Python. Запуск и коммуникация с другими программами. Обмен данными между процессами. Сигналы, пайпы, работа с общими дескрипторами. Использование пулов процессов.

### Процессы
Процессы в Python позволяют запустить выполнение нескольких задач в параллельном режиме. По сути, при старте процесса запускает еще одна копия интерпретатора Python, в котором выполняется указанная функция. Таким образом, если мы запустим пять процессов, то будет запущено пять отдельных интерпретаторов, в этом случае уже не будет проблем с GIL. Такой способ  позволяет параллельно запускать задачи активно использующие CPU. Они будут распределяться между несколькими процессами (ядрами), что значительно увеличит производительность вычислений.

Классом, который отвечает за создание и управление процессами является Process из пакета multiprocessing. Он совместим по сигнатурам методов и конструктора с threading.Thread, это сделано для более простого перехода от многопотокового приложения к многопроцессному. Помимо одноименных с Thread методов, класс Process дополнительно предоставляет ряд своих. Познакомимся поближе с этим классом, конструктор класса выглядит следующим образом:

```python
class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
```

### Мультипроцессинг в Python

Многопроцессорность позволяет двум или более процессорам одновременно обрабатывать две или более различных частей программы. В Python для реализации мультипроцессинга используется модуль multiprocessing.

Пример мультипроцессорной программы (без мультипроцессинга)
```python
import time

def task(n=100_000_000):
    while n:
        n -= 1

if __name__ == '__main__':
    start = time.perf_counter()
    task()
    task()
    finish = time.perf_counter()

    print(f'Выполнение заняло {finish-start: .2f} секунд.')
```

Пример мультипроцессорной программы (с мультипроцессингом)
```python
import time
import multiprocessing

def task(n=100_000_000):
    while n:
        n -= 1

if __name__  ==  '__main__':
    start = time.perf_counter()

    p1 = multiprocessing.Process(target=task)
    p2 = multiprocessing.Process(target=task)

    p1.start()
    p2.start()

    p1.join()
    p2.join()

    finish = time.perf_counter()

    print(f'Выполнение заняло {finish-start: .2f} секунд.')
```

### Запуск и коммуникация с другими программами

Для запуска и коммуникации с другими программами в многопроцессорной среде с использованием Python, можно воспользоваться библиотекой multiprocessing, которая предоставляет удобные средства для создания и управления процессами. Вот примеры того, как можно запустить другую программу и обмениваться данными между ней и основной программой:

1. Запуск внешней программы из Python:
```python
import subprocess

# Запустить внешнюю программу
subprocess.call(['python', 'external_program.py'])
```


2. Коммуникация между процессами с использованием модуля multiprocessing:

```python
from multiprocessing import Process, Queue

# Функция, которая будет выполнена в новом процессе
def worker_func(queue):
    data = queue.get()  # Получить данные из очереди
    print('Received data in worker:', data)

# Создание очереди для обмена данными между процессами
queue = Queue()

# Создание и запуск нового процесса с передачей очереди данных
worker_process = Process(target=worker_func, args=(queue,))
worker_process.start()

# Передача данных из основного процесса в рабочий процесс через очередь
data_to_send = 'Hello from main process!'
queue.put(data_to_send)

worker_process.join()  # Ожидание завершения работы рабочего процесса
```

### Обмен данными между процессами

В Python для обмена данными между процессами можно использовать различные механизмы, такие как Shared Memory, очереди (Queues) и каналы (Pipes) из модуля multiprocessing. 
примеры использования этих механизмов:

1. Shared Memory (разделяемая память):

- Разделяемая память позволяет нескольким процессам иметь доступ к общему участку памяти, где они могут хранить и читать данные. При использовании Shared Memory процессы могут эффективно обмениваться данными, так как они могут обращаться к памяти напрямую, без необходимости копирования данных между процессами.

```python
from multiprocessing import Process, Value

# Создание переменной типа Value для разделяемой памяти
shared_var = Value('i', 0)

# Функция, которая будет выполнена в отдельном процессе
def worker_func(shared_var):
    shared_var.value = 123

# Создание и запуск процесса
worker_process = Process(target=worker_func, args=(shared_var,))
worker_process.start()
worker_process.join()

# Чтение значения переменной из основного процесса
print("Value in main process:", shared_var.value)
```


2. Очереди (Queues):

- Очереди (Queues) представляют собой удобный и безопасный способ для обмена данными между процессами в Python. Очереди поддерживают добавление элементов в конец очереди (put) и извлечение элементов из начала очереди (get). Очереди также гарантируют безопасную передачу данных между процессами, так как встроены механизмы блокировки и синхронизации.


```python
from multiprocessing import Process, Queue

# Создание очереди для обмена данными между процессами
queue = Queue()

# Функция для записи данных в очередь
def producer(queue):
    data = [1, 2, 3]
    queue.put(data)

# Функция для чтения данных из очереди
def consumer(queue):
    data = queue.get()
    print("Data received in consumer:", data)

# Создание процессов для продюсера и консьюмера
producer_process = Process(target=producer, args=(queue,))
consumer_process = Process(target=consumer, args=(queue,))

producer_process.start()
consumer_process.start()

producer_process.join()
consumer_process.join()
```


3. Каналы (Pipes):
- Каналы (Pipes) представляют собой однонаправленные каналы связи между процессами в Python. Один конец канала используется для записи данных (send), а другой для чтения данных (recv). Каналы обеспечивают передачу данных между двумя процессами в одном направлении. При использовании каналов процессы взаимодействуют друг с другом по принципу "отправка-прием" сообщений.

```python
from multiprocessing import Process, Pipe

# Создание канала для обмена данными между процессами
parent_conn, child_conn = Pipe()

# Функция, которая будет отправлять данные в канал
def sender(connection):
    connection.send("Hello from sender!")

# Функция, которая будет принимать данные из канала
def receiver(connection):
    data = connection.recv()
    print("Data received in receiver:", data)

# Создание и запуск процессов
sender_process = Process(target=sender, args=(parent_conn,))
receiver_process = Process(target=receiver, args=(child_conn,))

sender_process.start()
receiver_process.start()

sender_process.join()
receiver_process.join()
```

4. Сигналы (signals):

- Сигналы в Unix-подобных операционных системах используются для уведомления процессов о различных событиях. Python предоставляет возможность обработки сигналов с помощью модуля signal. Вы можете установить обработчик сигнала для перехвата определенных сигналов, таких как SIGINT (сигнал прерывания) или SIGTERM (сигнал завершения процесса), и выполнить определенные действия в ответ на них.

5. Общие дескрипторы файлов (shared file descriptors):

- Общие дескрипторы файлов могут быть использованы для обмена данными между процессами с помощью файловой системы. В Python вы можете создать общий дескриптор файла с помощью модуля os и передать его между процессами для обмена данными через файл.


### Использование пулов процессов

Пул процессов (Process Pool) в Python представляет собой механизм для создания и управления группой параллельных процессов. Пул процессов упрощает распределение задач между несколькими процессами, что позволяет эффективно использовать многоядерные процессоры и увеличить производительность выполнения задач.

Для работы с пулом процессов в Python обычно используется модуль multiprocessing или сторонняя библиотека concurrent.futures. С помощью пула процессов можно создавать фиксированное количество процессов, которые будут выполнять задачи из очереди (Pool Queue) параллельно.

Преимущества использования пулов процессов в Python включают:
- Повышение производительности за счет одновременного выполнения нескольких задач на разных процессах
- Простота использования пула процессов за счет встроенного механизма управления процессами и передачи задач
- Улучшенная отказоустойчивость, так как каждый процесс работает в отдельном пространстве памяти
