Итератор - объект, представляющий последовательный доступ к данным из контейнера (память не тратится, так как промежуточные данные выдаются по мере необходимости при запросе).  Контейнер поддерживает итерирование, если определён метод __iter__. 
Итератор - объект, у которого определены два метода:
__iter__  - возвращает сам итератор
__next__ - возвращает очередной элемент или выбрасывает StopIteration (если элементы закончились)
Встроенные функции языка iter() и next() вызывают эти методы.
Итератор нельзя отмотать назад.
При итерировании по словарю будут возвращаться ключи
l = [1, 2, 3]
i = iter(l) # создание итератора. Можно применять к объектам, поддерживающим интерфейс итератора. iter(l) тоже самое что и l.__iter__().
Теперь можно использовать next:
next(i) # 1 тоже самое что и i.__next__() 
next(i) # 2
Если произойдет выход за границу, то сгенерируется StopIteration.
Пример итератора для функции range.


Предположим, мы хотим обработать набор каких-то данных. Обычно схема действий такова:
Создаем список, элементами которого являются данные, которые нам нужно обработать.
Обрабатываем элементы списка в цикле "for...in"
Но не всегда удобно действовать по такой схеме. Например, встретилась одна из следующих ситуаций:
Очень большой набор данных. Работать будет, но при этом займет много времени и оперативной памяти.
Большое время на получение одного элемента набора. Придется ждать, пока получим все данные набора, иногда это может занять немаленькое время. Предположим, нам нужно только несколько первых значений большого набора, а мы получаем или вычисляем все значения.
В таких случаях хорошо бы вычислять очередное значение только тогда, когда оно нам понадобится, а не вычислять все значения заранее. Это можно осуществить тремя путями:
Создать объект-итератор.
Создать функцию-генератор.
Использовать генераторное выражение.
Простейший итератор:
L = [1, 2, 3]
i = iter(L)

print(next(i)) # 1, ну и пока есть куда идти он будет выдавать следующие значения списка, пока не достигнет StopIteration

Пример итератора на цикле for: 

class Range:

    def __init__(self, start, end):
        self._start = start
        self._end = end
        self._current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self._current < self._end:
            self._current += 1
            return self._current-1
        else:
            raise StopIteration


Устройство цикла for
def _for(iterable_obj, loop_body):
    iter = iterable_obj.__iter__()
    while True:
        try:
            x = iter.__next__()
        except StopIteration:
            break
    loop_body(x)


# каноничный for
for i in range(10):
    print(i)


# не каноничный for
_for(range(10), print)


Генераторы
Генератор - объект, у которого определены пять методов:
__iter__()
__next__()
send(arg)
throw(type [, val [, tb]])
close()
Генератор похож на итератор, только является функцией. При вызове этой функции в цикле, она в каждой новой итерации выдает следующее значение. Пишется эта функция с использованием оператора yield.
yield работает как return, с одной разницей, что между вызовами функций, все состояния и данные будут при следующем вызове функции такими, какими они были на момент предыдущего исполнения yield.
По сути это ключевое слово создает итератор, просто создание итератора упрощается за счет того, что методы __iter__() и __next__() создаются автоматически. При выходе из функции не по оператору yield автоматически генерируется StopIteration. Когда вызывается next(), начинается выполнение функции.


Генераторная функция:
def Range(start, end):
    current = start
    while current < end:
        yield current
        current += 1
# Range(0, 5)  - возвращает генератор
for x in Range(0, 5): 
    print(x)



yield - возвращает значение, и указывает на место, с которого в следующий раз начнется функция


yield from <expr> - начиная с версии 3.3, эта конструкция - более короткий вариант for item in iterable: yield item
Эту конструкцию можно читать так: yield (вернуть значение) <стоп мыслей> from (взять значение из) <expr>
def gen(x):
    yield from range(x)
list(gen(5)) # [0, 1, 2, 3, 4]



Позволяет организовать связь между внутренним и внешним генератором.
send, применённый ко внешнему генератору, отправится во внутренний
Чтобы код работал нужно определить свой Range, который будет генератором:
def Range(st, en):
	cur = st
	while cur < en:
		res = yield cur
		if res in not None:
			cur = res - 1
		cur += 1

	


def two_ranges(start, stop):
   yield from Range(start, stop)
   yield from Range(start, stop)



g = two_ranges(0,3)
print(next(g)) # 0
print(next(g)) # 1
print(g.send(-1)) # -1
print(next(g)) # 0
print(next(g)) # 1
print(next(g)) # 2
print(next(g)) # 0 - уже из второго range



send - метод, позволяющий выполнить не только переход к следующему элементу в последовательности, но еще и обеспечивает для вызывающей программы способ взаимодействия с генератором, влияя на его работу.


Если вызывается next, то yield возвращает None, если же вызывается send(something),
то yield возвращает something.
def inc(start):
    current = start
    while True:
        reset = yield current
        current += 1
        if reset is not None:
            current = reset
i = inc(1)
print(next(i))
print(i.send(10)) # передается значение в reset





close() - возбуждает специальное GeneratorExit, чтобы вынудить завершить итерации.


throw(typ, [, val [,tb]]) -вызывает исключение в генераторе в строке с yield, так мы можем сообщить о каких - то обстоятельствах в генератор и там их обработать.
yield from пробрасывает и эти исключения.


def gen_items():
    for i, item in enumerate(["", "foo", "", "foo", "bad"]):
        if not item:
            continue
        try:
            yield item
        except Exception:
            raise Exception("error during index: %d" % i)



# Stack trace includes only: "ValueError: bad value"
for item in gen_items():
    if item == "bad":
        raise ValueError("bad value")



# Stack trace also includes: "Exception: error during index: 4"
gen = gen_items()
for item in gen:
    if item == "bad":
        gen.throw(ValueError, "bad value")



Генераторы
Генератор, это очень похоже на итератор, только это функция. При вызове этой функции в цикле, она при каждом новом цикле выдает следующее значение. Пишется эта функция с использованием оператора yield
yield работает как return, с одной разницей, что между вызовами функций, все состояния и данные будут при следующем вызове функции такими, какими они были на момент предыдущего исполнения yield.
По сути это ключевое слово создает итератор, просто создание итератора упрощается за счет того, что методы __iter__() и next() создаются автоматически. При выходе из функции не по оператору yield автоматически генерируется StopIteration.
def Range_v1(start, end):
    current = start
    while current < end:
        yield current
        current += 1

for x in Range_v1(0, 10):
    print(x)

Пример  с send

def inc(start):
    current = start
    while True:
        reset = yield current
        current += 1
        if reset is not None:
            current = reset

i = inc(0)

print(next(i))
print(i.send(10))
print(next(i))
Мы можем перескочить значения, стартуя от 0, отправив 10, дальше уже будет 11. 

Генераторные выражения(comprehensions)
Иногда, в простых случаях, можно не писать функцию-генератор, а обойтись генераторным выражением. Это такой синтаксис для создания простого генератора прямо в том месте, где это нужно.
g = (x*x for x in [1, 2, 3, 5, 6, 7, 8] if x % 2 == 0)
